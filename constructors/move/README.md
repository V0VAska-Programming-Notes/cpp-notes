# move constructor and move assignment operator

> Напоминание. Всегда лучше делать все неявные конструкторы и операторы "удалёнными", чтоб не допускать случайных ошибок. По мере надобности лучше потом либо разрешить их, либо написать свои.

## move constructor

A move constructor is a special member function that moves ownership of an existing object's data to a new variable without copying the original data. It takes an rvalue reference as its first parameter, and any later parameters must have default values. Move constructors can significantly increase your program's efficiency when passing around large objects.

The compiler chooses a move constructor when the object is initialized by another object of the same type, if the other object is about to be destroyed and no longer needs its resources. For example, calling a function that returns some object. The returned value is an xvalue (eXpiring value). It's not assigned to any variable and is therefore about to go out of scope.

```
class Boo
{
...
    Boo(Boo&&);
    Boo& operator=(Boo&&);
...
};

Boo foo()
{
...
return objBoo;
}

// move constructor
Boo obj_1(foo());

// move assignment
Boo obj_2 = foo();
```

A move constructor of class T is a non-template constructor whose first parameter is T&&, const T&&, volatile T&&, or const volatile T&&, and either there are no other parameters, or the rest of the parameters all have default values.

```
Syntax
class-name ( class-name && )                (1) 	(since C++11)
class-name ( class-name && ) = default;     (2) 	(since C++11)
class-name ( class-name && ) = delete;      (3) 	(since C++11)
```

Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.
Explanation
1) Typical declaration of a move constructor.
2) Forcing a move constructor to be generated by the compiler.
3) Avoiding implicit move constructor.

The move constructor is typically called when an object is initialized (by direct-initialization or copy-initialization) from rvalue (xvalue or prvalue) (until C++17)xvalue (since C++17) of the same type, including

    initialization: T a = std::move(b); or T a(std::move(b));, where b is of type T;
    function argument passing: f(std::move(a));, where a is of type T and f is void f(T t);
    function return: return a; inside a function such as T f(), where a is of type T which has a move constructor. 

When the initializer is a prvalue, the move constructor call is often optimized out (until C++17)never made (since C++17), see copy elision.

Move constructors typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.) rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, moving from a std::string or from a std::vector may result in the argument being left empty. However, this behavior should not be relied upon. For some types, such as std::unique_ptr, the moved-from state is fully specified. 

```c++
#include <iostream>

class Base
{
public:
    int *ptr;
    Base(int i): ptr{new int(i)}{}
    Base(const Base&) = delete;
    Base(Base&&);
    Base& operator=(const Base&) = delete;
    Base& operator=(Base&&) = delete;
    ~Base();
};

Base::Base(Base&& baseObj) : ptr{nullptr}
{
    this->ptr = baseObj.ptr;

    // do not forget to do this
    baseObj.ptr = nullptr;
}

Base::~Base()
{
    if (ptr != nullptr)
    {
        delete ptr;
        ptr = nullptr;
    }
}

int main(int argc, char *argv[])
{
    Base objBase{10};
    Base objBase1{std::move(objBase)};
    std::cout << "*(objBase1.ptr) = " << *(objBase1.ptr) << std::endl;
    return 0;
}
```

## move assignment operator

A move assignment operator of class T is a non-template non-static member function with the name operator= that takes exactly one parameter of type T&&, const T&&, volatile T&&, or const volatile T&&.

```
Syntax
class-name & class-name ::operator= ( class-name && )               (1) 	(since C++11)
class-name & class-name ::operator= ( class-name && ) = default;    (2) 	(since C++11)
class-name & class-name ::operator= ( class-name && ) = delete;     (3) 	(since C++11)
```

Explanation
1) Typical declaration of a move assignment operator.
2) Forcing a move assignment operator to be generated by the compiler.
3) Avoiding implicit move assignment.

The move assignment operator is called whenever it is selected by overload resolution, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.

Move assignment operators typically "steal" the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, I/O streams, running threads, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. For example, move-assigning from a std::string or from a std::vector may result in the argument being left empty. This is not, however, a guarantee. A move assignment is less, not more restrictively defined than ordinary assignment; where ordinary assignment must leave two copies of data at completion, move assignment is required to leave only one.

```c++
#include <iostream>

class Base
{
public:
    int *ptr;
    Base(int i): ptr{new int(i)}{}
    Base(const Base&) = delete;
    Base(Base&&);
    Base& operator=(const Base&) = delete;
    Base& operator=(Base&& objBase)
    {
        if (this != &objBase)
        {
            // free resources
            delete ptr;

            ptr = objBase.ptr;

            objBase.ptr = nullptr;
        }
        return *this;
    }
    ~Base();
};

Base::Base(Base&& baseObj) : ptr{nullptr}
{
    this->ptr = baseObj.ptr;

    // do not forget to do this
    baseObj.ptr = nullptr;
}

Base::~Base()
{
    if (ptr != nullptr)
    {
        delete ptr;
        ptr = nullptr;
    }
}

int main(int argc, char *argv[])
{
    Base objBase{10};
    Base objBase1{std::move(objBase)};
    std::cout << "*(objBase1.ptr) = " << *(objBase1.ptr) << std::endl;
    objBase = std::move(objBase1);
    std::cout << "*(objBase.ptr) = " << *(objBase.ptr) << std::endl;
    return 0;
}
```
