# copy constructor and copy assignment operator

> Напоминание. Всегда лучше делать все неявные конструкторы и операторы "удалёнными", чтоб не допускать случайных ошибок. По мере надобности лучше потом либо разрешить их, либо написать свои.

## copy constructor

A copy constructor initializes an object by copying the member values from an object of the same type. If your class members are all simple types such as scalar values, the compiler-generated copy constructor is sufficient and you don't need to define your own. If your class requires more complex initialization, then you need to implement a custom copy constructor. For example, if a class member is a pointer then you need to define a copy constructor to allocate new memory and copy the values from the other's pointed-to object. The compiler-generated copy constructor simply copies the pointer, so that the new pointer still points to the other's memory location.

- Initialization: Initialization occurs when you declare a new object, when you pass function arguments by value, or when you return by value from a function.
- Assignment: When one object's value is assigned to another object, the first object is copied to the second object.

A copy constructor of class T is a non-template constructor whose first parameter is T&‍, const T&‍, volatile T&‍, or const volatile T&‍, and either there are no other parameters, or the rest of the parameters all have default values.
Syntax:

```
class-name ( [const] class-name & ) 			(1) 	
class-name ( [const] class-name & ) = default; 	(2) 	(since C++11)
class-name ( [const] class-name & ) = delete; 	(3) 	(since C++11)
```

Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.
Explanation
1) Typical declaration of a copy constructor.
2) Forcing a copy constructor to be generated by the compiler.
3) Avoiding implicit generation of the copy constructor.

The copy constructor is called whenever an object is initialized (by direct-initialization or copy-initialization) from another object of the same type (unless overload resolution selects a better match or the call is elided), which includes

- initialization: T a = b; or T a(b);, where b is of type T;
- function argument passing: f(a);, where a is of type T and f is void f(T t);
- function return: return a; inside a function such as T f(), where a is of type T, which has no move constructor.

Вспомним наш [пример](../../Parameters/params-jokes). Вот его и рассмотрим.

Достаточно добавить `Base(const Base&) = delete;`, как нам не позволят компиляцию. Либо будем передавать параметр по ссылке, либо напишем свой "копи":

```c++
#include <iostream>

class Base
{
public:
    int *ptr;
    Base(const Base&);
    //Base& operator=(const Base&) = default;
    Base(int i): ptr{new int(i)}{}
    ~Base();
};

Base::Base(const Base& baseObj)
{
    this->ptr = new int{*(baseObj.ptr)};
}

Base::~Base()
{
    if (ptr != nullptr)
    {
        delete ptr;
        ptr = nullptr;
    }
}

void someFunc(Base param)
{
    std::cout << "Doing something: " << *(param.ptr) << std::endl;
}

int main(int argc, char *argv[])
{
    Base objBase{10};
    someFunc(objBase);
    std::cout << "LOL..." << std::endl;
    return 0;
}
```

## copy assignment operator

A copy assignment operator of class T is a non-template non-static member function with the name operator= that takes exactly one parameter of type T, T&, const T&, volatile T&, or const volatile T&. For a type to be CopyAssignable, it must have a public copy assignment operator.
Syntax

```
class-name & class-name ::operator= ( class-name )						(1) 	
class-name & class-name ::operator= ( const class-name & )				(2) 	
class-name & class-name ::operator= ( const class-name & ) = default; 	(3) 	(since C++11)
class-name & class-name ::operator= ( const class-name & ) = delete; 	(4) 	(since C++11)
```

Explanation
1) Typical declaration of a copy assignment operator when copy-and-swap idiom is used.
2) Typical declaration of a copy assignment operator when copy-and-swap idiom is not used.
3) Forcing a copy assignment operator to be generated by the compiler.
4) Avoiding implicit copy assignment.

The copy assignment operator is called whenever selected by overload resolution, e.g. when an object appears on the left side of an assignment expression.

```c++
#include <iostream>

class Base
{
public:
    int *ptr;
    Base(int i): ptr{new int(i)}{}
    Base(const Base&);
    Base& operator=(const Base& baseObj)
    {
        // not a self-assignment
        if(this != &baseObj)
        {
            delete this->ptr;
            this->ptr = new int{*(baseObj.ptr)};
        }
        return *this;
    }

    ~Base();
};

Base::Base(const Base& baseObj) : ptr{nullptr}
{
    this->ptr = new int{*(baseObj.ptr)};
}

Base::~Base()
{
    if (ptr != nullptr)
    {
        // do not forget to free resources
        delete ptr;
        ptr = nullptr;
    }
}

void someFunc(Base param)
{
    std::cout << "Doing something: " << *(param.ptr) << std::endl;
}

int main(int argc, char *argv[])
{
    Base objBase{10};
    // copy constructor
    someFunc(objBase);

    // copy constructor
    //Base objBase1 = objBase;
    
    Base objBase1{20};
    // copy assignment
    objBase1 = objBase;
    return 0;
}
```

